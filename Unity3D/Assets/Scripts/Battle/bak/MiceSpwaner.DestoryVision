using UnityEngine;
using System.Collections.Generic;
using MPProtocol;

public class MiceSpwaner : MonoBehaviour
{
    private int i;
    public float speed;
    public GameObject[] Mice;
    public GameObject myPanel;
    private GameObject clone;
    public GameObject[] Hole;
    private string holeRoot;

    private float lastTime;
    private float offsetTime;
    private float currentTime;
    private int[] arrLine;
    private int[] arrOppositeLine;
    private int[] arrHorizontal;
    private int[] arrCircle;
    private int[] arrOppositeCircle;
    private int[] arrHoleNum;

    HoleState holeState;
    //bool flag = true;

    List<int> listRnd;
    

    private void Start()
    {
        Global.MiceCount = 0;
        lastTime = offsetTime = currentTime = 0;
        i = 1;
        holeRoot = "GameUI/Camera/Battle(Panel)/Hole";
        arrLine = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };
        arrOppositeLine = new int[] { 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
        arrCircle = new int[] { 1, 2, 3, 6, 8, 10, 13, 11, 12, 9, 7, 4, 5 };
        arrOppositeCircle = new int[] { 1, 4, 7, 9, 12, 11, 13, 10, 8, 6, 3, 2, 5 };
        arrHorizontal = new int[] { 1, 4, 7, 9, 11, 12 };
    }


    private void Update()
    {
        Spwan((byte)SpwanStatus.ByNum, speed,2);
    }


    private void Spwan(byte status, float speed)
    {
        
        switch (status)
        {
            case (byte)SpwanStatus.Circle:
                {
                    //if (Global.MiceCount < Hole.Length && Global.MiceCount < arrCircle.Length)
                        OneByOne(arrCircle);
                    break;
                }
            case (byte)SpwanStatus.OppositeCircle:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrOppositeCircle.Length)
                        OneByOne(arrOppositeCircle);
                    break;
                }
            case (byte)SpwanStatus.Line:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrLine.Length)
                    {
                        OneByOne(arrLine);
                    }
                    break;
                }
            case (byte)SpwanStatus.OppositeLine:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrOppositeLine.Length)
                    {
                        OneByOne(arrOppositeLine);
                    }
                    break;
                }
            case (byte)SpwanStatus.Horizontal:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrHorizontal.Length)
                    {
                        OneByOne(arrHorizontal);
                    }
                    break;
                }
        }
    }

    private void Spwan(byte status, float speed, int spwanByNum)
    {
        switch (status)
        {
            case (byte)SpwanStatus.ByNum:
                {
                    if (Global.MiceCount < Hole.Length)
                    {
                        SpwanByNum(spwanByNum);
                    }
                    break;
                }
        }
    }

    private void OneByOne(int[] arrHoleNum) //現在是用老鼠數量當作陣列值，如果未來要改變成 自己的陣列值則需要修改Global.MiceCount
    {
        lock (this)
        {
            currentTime = Time.time;
            //Debug.Log("SpwanCount:" + i);
            if (currentTime - (lastTime - offsetTime) > speed /*&& Global.MiceCount < Hole.Length*/ && i % 14 > 0)
            {
                holeState = GameObject.Find(holeRoot + arrHoleNum[i-1].ToString()).GetComponent<HoleState>(); //i+1 => 0+1=1 PS:Hole1
                Debug.Log("i: "+i+"   arrHoleNum[i]:" + arrHoleNum[i-1]);
                if (holeState.holeState == HoleState.State.Open)
                {
                    clone = Instantiate(Mice[0], transform.position, transform.rotation) as GameObject;
                    clone.name = "Mice" + i.ToString();
                    clone.gameObject.transform.parent = Hole[arrHoleNum[i - 1] - 1].transform;  //-1是因為 Hole的起始值是0
                    clone.transform.localPosition = Vector3.zero;
                    clone.transform.localScale = Vector3.one;
                    clone.layer = 5; //5 = UI
                    clone.GetComponent<UI2DSprite>().depth = 2;
                    clone.transform.localRotation = Quaternion.Euler(Vector3.zero);
                    holeState.holeState = HoleState.State.Closed;

                    i++;
                    Global.MiceCount++;
                    lastTime = currentTime;
                }
                else
                {
                    i++;
                }

            }
            else if (i % 14 == 0)
            {
                i = 1;
            }
        }
    }

    /* 特殊版 沒打完不會再出
     *     private void OneByOne(int[] arrHoleNum) //現在是用老鼠數量當作陣列值，如果未來要改變成 自己的陣列值則需要修改Global.MiceCount
    {
        lock (this)
        {
            currentTime = Time.time;
            Debug.Log("SpwanCount:" + i);
            if (currentTime - (lastTime - offsetTime) > speed && Global.MiceCount < Hole.Length && i % 14 > 0)
            {
                holeState = GameObject.Find(holeRoot + i.ToString()).GetComponent<HoleState>(); //i+1 => 0+1=1 PS:Hole1
                if (holeState.holeState == HoleState.State.Open)
                {
                    clone = Instantiate(Mice[0], transform.position, transform.rotation) as GameObject;
                    clone.name = "Mice" + i.ToString();
                    clone.gameObject.transform.parent = Hole[arrHoleNum[i - 1] - 1].transform;  //-1是因為 Hole的起始值是0
                    clone.transform.localPosition = Vector3.zero;
                    clone.transform.localScale = Vector3.one;
                    clone.layer = 5; //5 = UI
                    clone.GetComponent<UI2DSprite>().depth = 2;
                    clone.transform.localRotation = Quaternion.Euler(Vector3.zero);
                    holeState.holeState = HoleState.State.Closed;

                    i++;
                    Global.MiceCount++;
                    lastTime = currentTime;
                }

            }
            else if (i % 14 == 0)
            {
                i = 1;
            }
        }
    }
     * *
     */

    private void SpwanByNum(int num) //random 2 ~ n
    {
        arrHoleNum = new int[num];
        currentTime = Time.time;
        listRnd = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };

        if (currentTime - (lastTime - offsetTime) > speed && Global.MiceCount < Hole.Length)  // random 2 ~ n Mice
        {
            for (int item = 0; item < arrHoleNum.Length; item++)
            {
                int rndRng = Random.Range(1, listRnd.Count + 1);
                arrHoleNum[item] = rndRng;
                listRnd.Remove(rndRng);
                Debug.Log(arrHoleNum[item]);
            }

            for (int item = 0; item < arrHoleNum.Length; item++)
            {

                holeState = GameObject.Find(holeRoot + arrHoleNum[item].ToString()).GetComponent<HoleState>(); //i+1 => 0+1=1 PS:Hole1
                if (holeState.holeState == HoleState.State.Open)
                {
                    if (Hole[arrHoleNum[item] - 1].GetComponentInChildren<UI2DSprite>().name != "")
                    {
                        clone = Instantiate(Mice[0], transform.position, transform.rotation) as GameObject;
                        clone.name = "EggMice";
                        clone.gameObject.transform.parent = Hole[arrHoleNum[item] - 1].transform;
                        clone.transform.localPosition = Vector3.zero;
                        clone.transform.localScale = Vector3.one;
                        clone.layer = 5; //5 = UI
                        clone.GetComponent<UI2DSprite>().depth = 2;
                        clone.transform.localRotation = Quaternion.Euler(Vector3.zero);
                        holeState.holeState = HoleState.State.Closed;
                        Global.MiceCount++;
                    }
                    else
                    {

                    }
                }
            }
            lastTime = currentTime;
            //flag = !flag;
        }
    }
}

