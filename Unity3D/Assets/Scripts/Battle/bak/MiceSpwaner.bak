using UnityEngine;
using System.Collections.Generic;
using MPProtocol;

public class MiceSpawn : MonoBehaviour
{
    private int i;
    public float speed;
    public GameObject[] Mice;
    public GameObject myPanel;
    private GameObject clone;
    public GameObject[] Hole;
    private string holeRoot;

    private float lastTime;
    private float offsetTime;
    private float currentTime;
    private int[] arrLine;
    private int[] arrOppositeLine;
    private int[] arrHorizontal;
    private int[] arrCircle;
    private int[] arrOppositeCircle;
    private int[] arrHoleNum;

    HoleState holeState;
    //bool flag = true;

    List<int> listRnd;


    private void Start()
    {
        Global.MiceCount = 0;
        lastTime = offsetTime = currentTime = 0;
        i = 1;
        holeRoot = "GameUI/Camera/Battle(Panel)/Hole";
        arrLine = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };
        arrOppositeLine = new int[] { 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
        arrCircle = new int[] { 1, 2, 3, 6, 8, 10, 13, 11, 12, 9, 7, 4, 5 };
        arrOppositeCircle = new int[] { 1, 4, 7, 9, 12, 11, 13, 10, 8, 6, 3, 2, 5 };
        arrHorizontal = new int[] { 1, 4, 7, 9, 11, 12 };

    }


    private void Update()
    {
        Spawn((byte)SpawnStatus.ByNum, speed, 2);
    }


    private void Spawn(byte status, float speed)
    {

        switch (status)
        {
            case (byte)SpawnStatus.Circle:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrCircle.Length)
                        OneByOne(arrCircle);
                    break;
                }
            case (byte)SpawnStatus.OppositeCircle:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrOppositeCircle.Length)
                        OneByOne(arrOppositeCircle);
                    break;
                }
            case (byte)SpawnStatus.Line:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrLine.Length)
                    {
                        OneByOne(arrLine);
                    }
                    break;
                }
            case (byte)SpawnStatus.OppositeLine:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrOppositeLine.Length)
                    {
                        OneByOne(arrOppositeLine);
                    }
                    break;
                }
            case (byte)SpawnStatus.Horizontal:
                {
                    if (Global.MiceCount < Hole.Length && Global.MiceCount < arrHorizontal.Length)
                    {
                        OneByOne(arrHorizontal);
                    }
                    break;
                }
        }
    }

    private void Spawn(byte status, float speed, int spwanByNum)
    {
        switch (status)
        {
            case (byte)SpawnStatus.ByNum:
                {
                    if (Global.MiceCount < Hole.Length)
                    {
                        SpwanByNum(spwanByNum);
                    }
                    break;
                }
        }
    }

    private void OneByOne(int[] arrHoleNum) //現在是用老鼠數量當作陣列值，如果未來要改變成 自己的陣列值則需要修改Global.MiceCount
    {
        Debug.Log("!");
        currentTime = Time.time;
        //Debug.Log("SpwanCount:" + i);
        if (currentTime - (lastTime - offsetTime) > speed && Global.MiceCount < Hole.Length && i % 14 > 0)  //有問題的話把Global.MiceCount < Hole.Length去掉
        {
            holeState = GameObject.Find(holeRoot + arrHoleNum[i - 1].ToString()).GetComponent<HoleState>(); //i+1 => 0+1=1 PS:Hole1

            if (holeState.holeState == HoleState.State.Open)
            {
                Debug.Log("OK");
                Hole[arrHoleNum[i - 1] - 1].transform.GetChild(2).transform.GetChild(0).collider.enabled = true;
                Hole[arrHoleNum[i - 1] - 1].transform.GetChild(2).transform.GetChild(0).GetComponent<UI2DSprite>().enabled = true; //這裡Hole[]不-1 因為item初始值=0 Hole[0]=第一個陣列值
                Hole[arrHoleNum[i - 1] - 1].transform.GetChild(2).transform.GetChild(0).GetComponent<EggMice>().Play();

                holeState.holeState = HoleState.State.Closed;

                i++;
                Global.MiceCount++;
                lastTime = currentTime;
            }
            else
            {
                i++; //防止地洞關閉了確不會尋找沒開的地洞
            }

        }
        else if (i % 14 == 0)
        {
            i = 1; // 當範圍超過13石回到1 (1~13個地洞)
        }

    }


    private void SpwanByNum(int num) //random 2 ~ n
    {
        arrHoleNum = new int[num];
        currentTime = Time.time;
        listRnd = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };

        if (currentTime - (lastTime - offsetTime) > speed && Global.MiceCount < Hole.Length)  // random 2 ~ n Mice
        {
            for (int item = 0; item < arrHoleNum.Length; item++)
            {
                int rndRng = Random.Range(1, listRnd.Count + 1);
                arrHoleNum[item] = rndRng;
                listRnd.Remove(rndRng);
                //Debug.Log(arrHoleNum[item]);
            }

            for (int item = 0; item < arrHoleNum.Length; item++)
            {

                holeState = GameObject.Find(holeRoot + arrHoleNum[item].ToString()).GetComponent<HoleState>(); //i+1 => 0+1=1 PS:Hole1
                if (holeState.holeState == HoleState.State.Open)
                {
                    Debug.Log("OK");
                    Hole[arrHoleNum[item] - 1].transform.GetChild(2).transform.GetChild(0).collider.enabled = true;
                    Hole[arrHoleNum[item] - 1].transform.GetChild(2).transform.GetChild(0).GetComponent<UI2DSprite>().enabled = true; //這裡Hole[]不-1 因為item初始值=0 Hole[0]=第一個陣列值
                    Hole[arrHoleNum[item] - 1].transform.GetChild(2).transform.GetChild(0).GetComponent<EggMice>().Play();

                    holeState.holeState = HoleState.State.Closed;
                    Global.MiceCount++;
                }
            }
            lastTime = currentTime;
            //flag = !flag;
        }
    }
}

